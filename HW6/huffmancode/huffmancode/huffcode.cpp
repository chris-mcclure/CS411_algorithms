// Chris McClure
// 12/6/19
//
// huffcode.cpp  UNFINISHED
// Glenn G. Chappell
// 29 Nov 2015
//
// For CS 411/611 Fall 2015
// Assignment 6, Exercise A
// Source for class HuffCode
//
// Modified 11/22/17
// Chris Hartman
// For CS 411 Fall 2017

#include "huffcode.hpp"  // for class HuffCode declaration
using std::string;
using std::unordered_map;
using std::shared_ptr;
using std::priority_queue;
using std::iterator;
using std::vector;
using std::make_shared;

/* Function setWeights sets the character weights. It is given
an unordered_map, as above; the value corresponding to a
character is its weight. Characters whose weight is not specified will
not occur in any texts to be encoded. */
void HuffCode::weightMap(Node & node, string code){
    if(node._weight > 0){
        if(node._key == 0){
            weightMap(*(node._leftNode), code + '0');
            weightMap(*(node._rightNode), code + '1');
        } else {
            lookup_map.insert({node._key, code});
        }
    }
}

void HuffCode::setWeights(const unordered_map<char, int> & theweights){
   /* sort priority queue from least to greatest */
    auto cmp = [&](auto & lhs, auto & rhs){
        return lhs._weight > rhs._weight;
    };
    
    priority_queue<Node, vector<Node>, decltype(cmp)> weight_queue(cmp);
    for(auto & weight: theweights){
        weight_queue.push(Node(weight.first, weight.second));
    }
    
    if(weight_queue.size() == 1){
        root = weight_queue.top();
        weight_queue.pop();
        auto lhs = make_shared<Node>(0,0);
        auto rhs = make_shared<Node>(0,0);
        weight_queue.pop();
        Node newNode(lhs, rhs, root._weight);
        weight_queue.push(newNode);
    }
    
    // create and add child nodes
    while(weight_queue.size() > 1){
        auto lhs = weight_queue.top();
        weight_queue.pop();
        auto rhs = weight_queue.top();
        weight_queue.pop();
        auto shared_lhs = make_shared<Node>(lhs);
        auto shared_rhs = make_shared<Node>(rhs);
        Node newNode(shared_lhs, shared_rhs, shared_lhs->_weight+shared_rhs->_weight);
        weight_queue.push(newNode);
    }
    
    // last element in priority is the root
    if(weight_queue.size() > 0){
        root = weight_queue.top();
        weight_queue.pop();
    }
    weightMap(root, "");
}

/* Given a string of characters, each of which has already had its
weight defined (using setWeights), this returns a string of zero
('0') and one ('1') characters, representing the given text,
encoded using an appropriate Huffman code. See Examples, below,
for an example. */
string HuffCode::encode(const string & text) const{
    string huffString = "";
    for(auto & letter: text){
        huffString += lookup_map.at(letter);
    }
    return huffString;
}


/* Given a string of zeroes and ones, encoded using the Huffman code
generated by the class, this returns the corresponding text. In
particular, if the return value of encode is passed to this function,
then it will return the argument of encode. See Examples, below,
for an example. */
string HuffCode::decode(const string & codestr) const{
    auto node = root;
    string huffCode = "";
    auto letter_it = codestr.begin();
    if(codestr.size() == 0)
        return "";
    while(letter_it != codestr.end()){
        if(*letter_it == '0'){
            node = *node._leftNode;
            letter_it++;
        }
        else if(*letter_it == '1'){
            node = *node._rightNode;
            letter_it++;
        }
        if(node._key != 0){
            huffCode += node._key;
            node = root;
            continue;
        }
    }
    return huffCode; 
}

